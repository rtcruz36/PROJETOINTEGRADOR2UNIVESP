diff --git a/apps/accounts/email.py b/apps/accounts/email.py
new file mode 100644
index 0000000000000000000000000000000000000000..2451a0846171eb057af58e55afe67f62e0ab04a9
--- /dev/null
+++ b/apps/accounts/email.py
@@ -0,0 +1,47 @@
+"""Custom Djoser e-mail classes for the accounts app."""
+
+from djoser import email as djoser_email
+
+
+class ActivationEmail(djoser_email.ActivationEmail):
+    """Activation e-mail using the project's default configuration."""
+
+
+class ConfirmationEmail(djoser_email.ConfirmationEmail):
+    """Confirmation e-mail used after account activation."""
+
+
+class PasswordResetEmail(djoser_email.PasswordResetEmail):
+    """Password reset e-mail that includes the reset confirmation link."""
+
+
+class PasswordResetConfirmationEmail(djoser_email.PasswordResetConfirmationEmail):
+    """Password reset confirmation e-mail."""
+
+
+class PasswordChangedConfirmationEmail(djoser_email.PasswordChangedConfirmationEmail):
+    """Notification sent once a password change has been completed."""
+
+
+class UsernameChangedConfirmationEmail(djoser_email.UsernameChangedConfirmationEmail):
+    """Notification sent after the username has been changed."""
+
+
+class UsernameResetEmail(djoser_email.UsernameResetEmail):
+    """Username reset e-mail containing the reset instructions."""
+
+
+class UsernameResetConfirmationEmail(djoser_email.UsernameResetConfirmationEmail):
+    """Confirmation e-mail sent after a username reset is completed."""
+
+
+__all__ = [
+    'ActivationEmail',
+    'ConfirmationEmail',
+    'PasswordResetEmail',
+    'PasswordResetConfirmationEmail',
+    'PasswordChangedConfirmationEmail',
+    'UsernameChangedConfirmationEmail',
+    'UsernameResetEmail',
+    'UsernameResetConfirmationEmail',
+]
diff --git a/apps/accounts/tests.py b/apps/accounts/tests.py
index 71a0171ce20127cd58190d5a87a70bd0a32b1459..9f958a8410891c3860da0c3e5e5ceedde0bd07e2 100644
--- a/apps/accounts/tests.py
+++ b/apps/accounts/tests.py
@@ -1,36 +1,36 @@
 # apps/accounts/tests.py
 
+import re
+
+from django.core import mail
 from django.urls import reverse
 from rest_framework import status
 from rest_framework.test import APITestCase
 from apps.accounts.models import User, Profile
-from django.test import TestCase
+from django.test import TestCase, override_settings
 from django.contrib.auth import get_user_model
-from unittest.mock import patch
-from rest_framework import status
-from django.urls import reverse
 
 
 
 User = get_user_model()
 
 class AccountsModelsAndSignalsTests(TestCase):
     def test_user_str_returns_email(self):
         u = User.objects.create_user(username="john", email="john@example.com", password="x")
         self.assertEqual(str(u), "john@example.com")  # cobre User.__str__
 
     def test_profile_str_uses_username(self):
         u = User.objects.create_user(username="ana", email="ana@example.com", password="x")
         # sinal deve ter criado o profile
         p = Profile.objects.get(user=u)
         self.assertIn("Perfil de ana", str(p))  # cobre Profile.__str__
 
     def test_signal_recreates_profile_when_missing_on_update(self):
     
     #Cobre o ramo do sinal post_save com created=False e sem atributo 'profile':#
    # - cria usuário (created=True -> já cobre a criação)#
     #- apaga o Profile#
    # - salva o usuário de novo (created=False), o sinal deve recriar o Profile
 
     # Cria um usuário, o que gera automaticamente um perfil via sinal
         u = User.objects.create_user(username="maria", email="maria@example.com", password="x")
@@ -171,25 +171,73 @@ class AccountsAPITests(APITestCase):
 
         self.assertEqual(refresh_response.status_code, status.HTTP_200_OK)
         self.assertIn('access', refresh_response.data)
         self.assertNotEqual(original_access, refresh_response.data['access'])
 
     def test_jwt_verify_endpoint_accepts_valid_token(self):
         User.objects.create_user(username='verifyuser', email='verify@example.com', password='password')
 
         login_response = self.client.post(
             reverse('jwt-create'),
             {"email": "verify@example.com", "password": "password"},
             format='json',
         )
 
         self.assertEqual(login_response.status_code, status.HTTP_200_OK)
         access_token = login_response.data['access']
 
         verify_response = self.client.post(
             reverse('jwt-verify'),
             {"token": access_token},
             format='json',
         )
 
         self.assertEqual(verify_response.status_code, status.HTTP_200_OK)
         self.assertEqual(verify_response.data, {})
+
+
+class PasswordResetFlowTests(APITestCase):
+    @override_settings(EMAIL_BACKEND='django.core.mail.backends.locmem.EmailBackend')
+    def test_password_reset_flow_sends_email_and_confirms_new_password(self):
+        user = User.objects.create_user(
+            username='resetuser',
+            email='reset@example.com',
+            password='initialPassword123',
+        )
+
+        response = self.client.post(
+            '/api/accounts/auth/users/reset_password/',
+            {'email': user.email},
+            format='json',
+        )
+
+        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
+        self.assertEqual(len(mail.outbox), 1)
+
+        email_body = mail.outbox[0].body
+        match = re.search(
+            r'#/password/reset/confirm/(?P<uid>[^/]+)/(?P<token>[^\s/]+)',
+            email_body,
+        )
+        self.assertIsNotNone(match, 'Password reset e-mail should contain uid and token')
+
+        confirm_response = self.client.post(
+            '/api/accounts/auth/users/reset_password_confirm/',
+            {
+                'uid': match.group('uid'),
+                'token': match.group('token'),
+                'new_password': 'NewPassword456!',
+                're_new_password': 'NewPassword456!',
+            },
+            format='json',
+        )
+
+        self.assertEqual(confirm_response.status_code, status.HTTP_204_NO_CONTENT)
+
+        login_response = self.client.post(
+            reverse('jwt-create'),
+            {'email': user.email, 'password': 'NewPassword456!'},
+            format='json',
+        )
+
+        self.assertEqual(login_response.status_code, status.HTTP_200_OK)
+        self.assertIn('access', login_response.data)
diff --git a/config/settings.py b/config/settings.py
index 19660463d11b83d30bf7d97eb212d885cb385491..2c326788c1c631931c0230d3f040e428294e692c 100644
--- a/config/settings.py
+++ b/config/settings.py
@@ -115,103 +115,121 @@ REST_FRAMEWORK = {
     'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
 }
 
 # Configuração do Simple JWT
 from datetime import timedelta
 
 SIMPLE_JWT = {
     'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60), # Duração do token de acesso (curto)
     'REFRESH_TOKEN_LIFETIME': timedelta(days=7),    # Duração do token de refresh (longo)
     'ROTATE_REFRESH_TOKENS': True, # Opcional: gera um novo refresh token a cada uso
     'BLACKLIST_AFTER_ROTATION': True, # Opcional: invalida o refresh token antigo
 }
 
 # Configuração do Djoser
 DJOSER = {
     'PASSWORD_RESET_CONFIRM_URL': '#/password/reset/confirm/{uid}/{token}',
     'USERNAME_RESET_CONFIRM_URL': '#/username/reset/confirm/{uid}/{token}',
     'ACTIVATION_URL': '#/activate/{uid}/{token}',
     'SEND_ACTIVATION_EMAIL': False,  # Mude para True se quiser confirmação por e-mail
     'SERIALIZERS': {
         'user_create': 'apps.accounts.serializers.UserCreateSerializer',
         'user': 'apps.accounts.serializers.UserSerializer',
         'current_user': 'apps.accounts.serializers.UserSerializer',
         'set_password': 'apps.accounts.serializers.SetPasswordSerializer',
     },
+    'EMAIL': {
+        'activation': 'apps.accounts.email.ActivationEmail',
+        'confirmation': 'apps.accounts.email.ConfirmationEmail',
+        'password_reset': 'apps.accounts.email.PasswordResetEmail',
+        'password_reset_confirmation': 'apps.accounts.email.PasswordResetConfirmationEmail',
+        'password_changed_confirmation': 'apps.accounts.email.PasswordChangedConfirmationEmail',
+        'username_changed_confirmation': 'apps.accounts.email.UsernameChangedConfirmationEmail',
+        'username_reset': 'apps.accounts.email.UsernameResetEmail',
+        'username_reset_confirmation': 'apps.accounts.email.UsernameResetConfirmationEmail',
+    },
     'USER_ID_FIELD': 'id',
     'LOGIN_FIELD': 'email', # Usar email para login
     'PERMISSIONS': {
         'set_password': (
             'rest_framework.permissions.IsAuthenticated',
         ),
+        'password_reset': (
+            'rest_framework.permissions.AllowAny',
+        ),
     },
 }
 
 # Password validation
 # https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators
 
 AUTH_PASSWORD_VALIDATORS = [
     {
         'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
     },
     {
         'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
     },
     {
         'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
     },
     {
         'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
     },
 ]
 
 
 # Internationalization
 # https://docs.djangoproject.com/en/5.2/topics/i18n/
 
 LANGUAGE_CODE = 'en-us'
 
 TIME_ZONE = 'UTC'
 
 USE_I18N = True
 
 USE_TZ = True
 
 
 # Static files (CSS, JavaScript, Images)
 # https://docs.djangoproject.com/en/5.2/howto/static-files/
 
 STATIC_URL = 'static/'
 
 # Default primary key field type
 # https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field
 
 DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
 
 SECRET_KEY = config('SECRET_KEY')
 DEEPSEEK_API_KEY = config('DEEPSEEK_API_KEY')
 
+EMAIL_BACKEND = config(
+    'EMAIL_BACKEND', default='django.core.mail.backends.console.EmailBackend'
+)
+DEFAULT_FROM_EMAIL = config('DEFAULT_FROM_EMAIL', default='no-reply@example.com')
+
 AUTH_USER_MODEL = 'accounts.User'
 
 
 if 'test' in sys.argv:
     DATABASES = {
         'default': {
             'ENGINE': 'django.db.backends.sqlite3',
             'NAME': ':memory:'  # Banco em memória para testes mais rápidos
         }
     }
     
     # Desabilitar migrações desnecessárias em testes
     class DisableMigrations:
         def __contains__(self, item):
             return True
         def __getitem__(self, item):
             return None
     
     MIGRATION_MODULES = DisableMigrations()
     
     
 SPECTACULAR_SETTINGS = {
     'TITLE': 'StudyPlatform API',
     'DESCRIPTION': 'Documentação da API para a plataforma de estudos StudyPlatform',
     'VERSION': '1.0.0',
        'SERVE_INCLUDE_SCHEMA': False}